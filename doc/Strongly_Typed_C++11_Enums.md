Somewhat unexpected size-related behavior of C++ enums...

When an enum is **not** strongly typed, and code (e.g. a unit test) forces a reasonable but invalid
enum value, GCC compilers emit a warning if the invalid enum value is sufficiently large that it
doesn't fit in the compiler's "interim" representation of the enum. What constitutes the "interim"
representation is what makes this behavior unexpected.

Consider this code:

```cpp
#include <iostream>
using namespace std;

enum Enum1_1Val
{
    enum1_1,
};

enum Enum2_3Vals
{
    enum2_1,
    enum2_2,
    enum2_3,
};

enum Enum3_5Vals
{
    enum3_1,
    enum3_2,
    enum3_3,
    enum3_4,
    enum3_5,
};

enum Enum4_5Vals : uint8_t
{
    enum4_1,
    enum4_2,
    enum4_3,
    enum4_4,
    enum4_5,
};

int main()
{
    cout << "sizeof(Enum1_1Val)=" << sizeof(Enum1_1Val) << endl;
    Enum1_1Val e1a = static_cast<Enum1_1Val>(1);
    cout << "e1a=" << e1a << endl;
    Enum1_1Val e1b = (Enum1_1Val)2;
    cout << "e1b=" << e1b << endl << endl;

    cout << "sizeof(Enum2_3Vals)=" << sizeof(Enum2_3Vals) << endl;
    Enum2_3Vals e2a = static_cast<Enum2_3Vals>(3);
    cout << "e2a=" << e2a << endl;
    Enum2_3Vals e2b = static_cast<Enum2_3Vals>(4);
    cout << "e2b=" << e2b << endl << endl;

    cout << "sizeof(Enum3_5Vals)=" << sizeof(Enum3_5Vals) << endl;
    Enum3_5Vals e3a = (Enum3_5Vals)7;
    cout << "e3a=" << e3a << endl;
    Enum3_5Vals e3b = (Enum3_5Vals)8;
    cout << "e3b=" << e3b << endl << endl;

    cout << "sizeof(Enum4_5Vals)=" << sizeof(Enum4_5Vals) << endl;
    Enum4_5Vals e4a = static_cast<Enum4_5Vals>(8);
    cout << "e4a=" << e4a << endl;
    Enum4_5Vals e4b = static_cast<Enum4_5Vals>(256);
    cout << "e4b=" << e4b << endl << endl;

    return 0;
}
```

What is the compiler's interim representation of `Enum3_5Vals`? You might be tempted to say `int`
but you'd be wrong -- at least at some level. As an example, the `Enum3_5Vals` enum has only five
values, such that the entire range of the enum can fit in 3 bits. For this enum, GCC's interim
representation is a 3-bit type so that an invalid value of `8` produces a compiler warning because
`8` doesn't fit in 3 bits. This warning is generated _even with a C-style-no-kidding cast_, such as
`val = (Enum3_5Vals)8`. Warnings generated by the above code look like this:


```
/home/ahelten/amh_devel/cool-cpp/EnumSizes.cpp: In function ‘int main()’:
/home/ahelten/amh_devel/cool-cpp/EnumSizes.cpp:39:34: warning: the result of the conversion is unspecified because ‘2’ is outside the range of type ‘Enum1_1Val’ [-Wconversion]
     Enum1_1Val e1b = (Enum1_1Val)2;
                                  ^
/home/ahelten/amh_devel/cool-cpp/EnumSizes.cpp:45:49: warning: the result of the conversion is unspecified because ‘4’ is outside the range of type ‘Enum2_3Vals’ [-Wconversion]
     Enum2_3Vals e2b = static_cast<Enum2_3Vals>(4);
                                                 ^
/home/ahelten/amh_devel/cool-cpp/EnumSizes.cpp:51:36: warning: the result of the conversion is unspecified because ‘8’ is outside the range of type ‘Enum3_5Vals’ [-Wconversion]
     Enum3_5Vals e3b = (Enum3_5Vals)8;
                                    ^
/home/ahelten/amh_devel/cool-cpp/EnumSizes.cpp:57:51: warning: the result of the conversion is unspecified because ‘256’ is outside the range of type ‘Enum4_5Vals’ [-Wconversion]
     Enum4_5Vals e4b = static_cast<Enum4_5Vals>(256);
                                                   ^
```

On the other hand, if an invalid value of `7` is used instead, the compiler doesn't complain because
the value fits in 3 bits -- it is irrelevant that `7` is outside the valid enum set (but only
because the C-style or `static_cast<>()` stops the warnings!). Meanwhile, on a 64-bit machine,
`sizeof(Enum3_5Vals)=4` reveals the real type is `int` or `unsigned int` (a fairly common choice for
compilers but not dictated by C/C++ standards).

Extend this to a strongly-typed enum, such as `enum Enum4_5Vals : uint8_t`. Does the compiler emit
warnings in the above scenarios? It might *not* be surprising that no warning is generated so long
as the invalid values fit in the strongly-typed `uint8_t` type. So the original invalid value of `7`
produces a warning for the legacy (untyped) enum but does not produce a warning for the
strongly-typed `uint8_t` enum -- even though the actual type of the legacy enum was *larger* than
the strongly typed version. If `256` was the invalid enum value instead of `7`, both untyped and
strongly-typed enums would have generated compiler warnings because `256` doesn't fit in either 3
bits or 8 bits.

To summarize, the (GCC) compiler behavior can be described something like this: an untyped enum
that can fit in 3 bits will be considered to have an interim type with a size of 3 bits even
though the real type is `int`. A strongly-typed enum simply forces this interim type to something
larger than the default bit-sized type. Furthermore, the compiler only generates a warning if
the value assigned doesn't fit in the interim type. Note that since enum sizing behavior is
implementation-defined, non-GCC compilers may behave differently.

One last thought, how do we write warning-free unit code test that requires setting invalid enum
values? Obviously, the invalid value must fit in the compiler's interim representation. This might
not be possible if the number of valid enum values fits perfectly in the interim representation. In
that case, you must either tolerate the warning or disable it using the `-Wno-conversion` compiler
flag *for only that unit test source file*. In CMake, add compiler flags for a specific build target
like this:

```
add_executable(EnumSizes EnumSizes.cpp)
target_compile_options(EnumSizes PRIVATE "-Wno-conversion")
```
